import express from 'express';
import { createServer } from 'http';
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import fs from 'fs';
import path from 'path';
import AWS from 'aws-sdk';
import { PubSub } from 'graphql-subscriptions';
import dotenv from 'dotenv';
import bodyParser from 'body-parser';
import cors from 'cors';
import { fileURLToPath } from 'url';

dotenv.config();

// Emulate __dirname for ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load GraphQL schema
const typeDefs = fs.readFileSync(path.join(__dirname, 'schema.graphql'), 'utf8');

// AWS SDK config
AWS.config.update({ region: process.env.AWS_REGION || 'us-east-1' });
const ddb = new AWS.DynamoDB.DocumentClient();
const S3 = new AWS.S3();
const TABLE = process.env.DDB_TABLE || 'YourDynamoDBTable';

// PubSub for subscriptions
const pubsub = new PubSub();
const CREATED = 'DOC_CREATED';
const UPDATED = 'DOC_UPDATED';

// Resolvers
const resolvers = {
  Query: {
    getDocument: async (_, { ObjectKey }) => {
      const res = await ddb.get({ TableName: TABLE, Key: { PK: ObjectKey, SK: ObjectKey } }).promise();
      return res.Item || null;
    },
    listDocuments: async () => {
      const res = await ddb.scan({ TableName: TABLE, Limit: 100 }).promise();
      return { Documents: res.Items || [], nextToken: null };
    },
    getFileContents: async (_, { s3Uri }) => {
      const [_, bucket, ...keyParts] = s3Uri.replace('s3://', '').split('/');
      const key = keyParts.join('/');
      const res = await S3.getObject({ Bucket: bucket, Key: key }).promise();
      return {
        content: res.Body.toString('utf-8'),
        contentType: res.ContentType,
        size: res.ContentLength,
        isBinary: false,
      };
    },
  },

  Mutation: {
    createDocument: async (_, { input }) => {
      const key = input.ObjectKey || `doc-${Date.now()}`;
      const item = { PK: key, SK: key, ...input };
      await ddb.put({ TableName: TABLE, Item: item }).promise();
      pubsub.publish(CREATED, { onCreateDocument: { ObjectKey: key } });
      return { ObjectKey: key };
    },

    updateDocument: async (_, { input }) => {
      const key = input.ObjectKey;
      if (!key) throw new Error('ObjectKey required');

      let expr = 'set';
      const attrNames = {}, attrValues = {};
      for (const [k, v] of Object.entries(input)) {
        if (k === 'ObjectKey') continue;
        expr += ` #${k} = :${k},`;
        attrNames[`#${k}`] = k;
        attrValues[`:${k}`] = v;
      }
      expr = expr.slice(0, -1);

      const res = await ddb.update({
        TableName: TABLE,
        Key: { PK: key, SK: key },
        UpdateExpression: expr,
        ExpressionAttributeNames: attrNames,
        ExpressionAttributeValues: attrValues,
        ReturnValues: 'ALL_NEW'
      }).promise();

      pubsub.publish(UPDATED, { onUpdateDocument: res.Attributes });
      return res.Attributes;
    },

    deleteDocument: async (_, { objectKeys }) => {
      const chunks = [];
      for (let i = 0; i < objectKeys.length; i += 25) {
        chunks.push(objectKeys.slice(i, i + 25));
      }
      for (const chunk of chunks) {
        await ddb.batchWrite({
          RequestItems: {
            [TABLE]: chunk.map(k => ({ DeleteRequest: { Key: { PK: k, SK: k } }}))
          }
        }).promise();
      }
      return true;
    },
  },

  Subscription: {
    onCreateDocument: { subscribe: () => pubsub.asyncIterator(CREATED) },
    onUpdateDocument: { subscribe: () => pubsub.asyncIterator(UPDATED) },
  },
};

// Schema
const schema = makeExecutableSchema({ typeDefs, resolvers });

// Server
async function start() {
  const app = express();
  const httpServer = createServer(app);

  const wsServer = new WebSocketServer({ server: httpServer, path: '/graphql' });
  const serverCleanup = useServer({ schema }, wsServer);

  const apollo = new ApolloServer({
    schema,
    plugins: [
      ApolloServerPluginDrainHttpServer({ httpServer }),
      {
        async serverWillStart() {
          return { async drainServer() { await serverCleanup.dispose(); } };
        }
      }
    ],
  });

  await apollo.start();
  app.use('/graphql', cors(), bodyParser.json(), expressMiddleware(apollo));

  const port = process.env.PORT || 4000;
  httpServer.listen(port, () => {
    console.log(`ðŸš€ GraphQL ready at http://localhost:${port}/graphql`);
    console.log(`ðŸ“¡ Subscriptions via ws://localhost:${port}/graphql`);
  });
}

start();
